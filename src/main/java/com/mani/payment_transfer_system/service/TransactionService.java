package com.mani.payment_transfer_system.service;

import com.mani.payment_transfer_system.exception.AccountNotFoundException;
import com.mani.payment_transfer_system.exception.InsufficientBalanceException;
import com.mani.payment_transfer_system.exception.InvalidAmountException;
import com.mani.payment_transfer_system.exception.TransactionNotFoundException;
import com.mani.payment_transfer_system.entity.Account;
import com.mani.payment_transfer_system.entity.Transaction;
import com.mani.payment_transfer_system.dto.TransactionRequest;
import com.mani.payment_transfer_system.dto.TransactionResponse;
import com.mani.payment_transfer_system.repository.AccountRepository;
import com.mani.payment_transfer_system.repository.TransactionRepository;
import io.micrometer.core.instrument.Timer;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Isolation;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Service layer for transaction-related operations.
 * Ensures data integrity through transaction management and pessimistic locking
 * to prevent race conditions and maintain ACID properties.
 */
@Service
public class TransactionService {

    private static final Logger logger = LoggerFactory.getLogger(TransactionService.class);
    private final AccountRepository accountRepository;
    private final TransactionRepository transactionRepository;
    private final MetricsService metricsService;

    /**
     * Constructs a new TransactionService with the given repositories.
     *
     * @param accountRepository the account repository for account operations
     * @param transactionRepository the transaction repository for transaction logging
     * @param metricsService the metrics service for recording metrics
     */
    public TransactionService(AccountRepository accountRepository, TransactionRepository transactionRepository, MetricsService metricsService) {
        this.accountRepository = accountRepository;
        this.transactionRepository = transactionRepository;
        this.metricsService = metricsService;
    }

    /**
     * Processes a transaction between two accounts.
     * Uses pessimistic locking to prevent race conditions and ensures atomic updates.
     * Locks accounts in sorted order by account ID to prevent deadlocks.
     *
     * @param request the transaction request
     * @return the unique transaction identifier generated by the database
     * @throws AccountNotFoundException if source or destination account is not found
     * @throws InsufficientBalanceException if source account has insufficient balance
     * @throws InvalidAmountException if the transaction amount is invalid
     */
    @Transactional(isolation = Isolation.READ_COMMITTED)
    public Long processTransaction(TransactionRequest request) {
        Timer.Sample timer = metricsService.startTransactionTimer();
        try {
            logger.debug("Processing transaction: source={}, destination={}, amount={}",
                    request.getSourceAccountId(), request.getDestinationAccountId(), request.getAmount());

            validateTransactionRequest(request);
            
            // Sort account IDs to ensure consistent lock ordering (prevents deadlocks)
            Long sourceId = request.getSourceAccountId();
            Long destId = request.getDestinationAccountId();
            
            // Always lock in ascending order by account ID to prevent deadlocks
            Long firstAccountId = Math.min(sourceId, destId);
            Long secondAccountId = Math.max(sourceId, destId);
            
            // Lock accounts in sorted order (ascending by account ID)
            Account firstAccount = lockAndRetrieveAccount(firstAccountId,
                    firstAccountId.equals(sourceId) ? "source" : "destination");
            Account secondAccount = lockAndRetrieveAccount(secondAccountId,
                    secondAccountId.equals(sourceId) ? "source" : "destination");
            
            // Map back to source/destination based on original request
            Account sourceAccount = firstAccountId.equals(sourceId) ? firstAccount : secondAccount;
            Account destinationAccount = firstAccountId.equals(sourceId) ? secondAccount : firstAccount;
            
            validateSufficientBalance(sourceAccount, request.getAmount());
            executeTransfer(sourceAccount, destinationAccount, request.getAmount());
            Long transactionId = logTransaction(request);
            
            // Record successful transaction metrics
            metricsService.recordTransaction(request.getAmount());
            
            return transactionId;
        } finally {
            metricsService.stopTransactionTimer(timer);
        }
    }

    /**
     * Validates the transaction request.
     *
     * @param request the transaction request to validate
     * @throws InvalidAmountException if validation fails
     */
    private void validateTransactionRequest(TransactionRequest request) {
        if (request.getAmount().compareTo(BigDecimal.ZERO) <= 0) {
            logger.warn("Invalid transaction amount: {}", request.getAmount());
            metricsService.recordInvalidAmountError();
            throw new InvalidAmountException("Transaction amount must be positive");
        }

        if (request.getSourceAccountId().equals(request.getDestinationAccountId())) {
            logger.warn("Attempt to transfer to same account: {}", request.getSourceAccountId());
            metricsService.recordInvalidAmountError();
            throw new InvalidAmountException("Source and destination accounts must be different");
        }
    }

    /**
     * Locks and retrieves an account with pessimistic write lock.
     *
     * @param accountId the account ID to retrieve
     * @param accountType the type of account (source/destination) for logging
     * @return the locked account
     * @throws AccountNotFoundException if account is not found
     */
    private Account lockAndRetrieveAccount(Long accountId, String accountType) {
        logger.debug("Locking {} account: {}", accountType, accountId);
        return accountRepository.findByAccountIdWithLock(accountId)
                .orElseThrow(() -> {
                    logger.warn("{} account not found: {}", accountType, accountId);
                    metricsService.recordAccountNotFoundError();
                    return new AccountNotFoundException(accountId);
                });
    }

    /**
     * Validates that the source account has sufficient balance.
     *
     * @param sourceAccount the source account
     * @param amount the transaction amount
     * @throws InsufficientBalanceException if balance is insufficient
     */
    private void validateSufficientBalance(Account sourceAccount, BigDecimal amount) {
        if (sourceAccount.getBalance().compareTo(amount) < 0) {
            logger.warn("Insufficient balance in account {}: current={}, requested={}",
                    sourceAccount.getAccountId(), sourceAccount.getBalance(), amount);
            metricsService.recordInsufficientBalanceError();
            throw new InsufficientBalanceException(
                    sourceAccount.getAccountId(),
                    sourceAccount.getBalance(),
                    amount
            );
        }
    }

    /**
     * Executes the transfer between two accounts atomically.
     *
     * @param sourceAccount the source account
     * @param destinationAccount the destination account
     * @param amount the amount to transfer
     */
    private void executeTransfer(Account sourceAccount, Account destinationAccount, BigDecimal amount) {
        logger.debug("Executing transfer: source balance={}, destination balance={}, amount={}",
                sourceAccount.getBalance(), destinationAccount.getBalance(), amount);

        BigDecimal newSourceBalance = sourceAccount.getBalance().subtract(amount);
        BigDecimal newDestinationBalance = destinationAccount.getBalance().add(amount);

        sourceAccount.setBalance(newSourceBalance);
        destinationAccount.setBalance(newDestinationBalance);

        accountRepository.saveAll(List.of(sourceAccount, destinationAccount));
        logger.debug("Account balances updated: source={}, destination={}",
                newSourceBalance, newDestinationBalance);
    }

    /**
     * Logs the transaction to the database.
     *
     * @param request the transaction request
     * @return the unique transaction identifier generated by the database
     */
    private Long logTransaction(TransactionRequest request) {
        Transaction transaction = new Transaction(
                request.getSourceAccountId(),
                request.getDestinationAccountId(),
                request.getAmount()
        );
        transactionRepository.save(transaction);
        Long transactionId = transaction.getId();
        logger.debug("Transaction logged successfully with ID: {}", transactionId);
        return transactionId;
    }

    /**
     * Retrieves a transaction by its unique identifier.
     *
     * @param transactionId the unique transaction identifier
     * @return TransactionResponse containing transaction details including ID, source account,
     *         destination account, amount, and timestamp
     * @throws TransactionNotFoundException if the transaction is not found
     */
    @Transactional(readOnly = true)
    public TransactionResponse getTransactionById(Long transactionId) {
        logger.debug("Retrieving transaction with ID: {}", transactionId);
        Transaction transaction = transactionRepository.findById(transactionId)
                .orElseThrow(() -> {
                    logger.warn("Transaction not found with ID: {}", transactionId);
                    metricsService.recordError();
                    return new TransactionNotFoundException(transactionId);
                });

        metricsService.recordTransactionQuery();
        logger.debug("Transaction retrieved successfully with ID: {}", transactionId);
        return new TransactionResponse(
                transaction.getId(),
                transaction.getSourceAccountId(),
                transaction.getDestinationAccountId(),
                transaction.getAmount(),
                transaction.getTimestamp()
        );
    }

    /**
     * Retrieves all transactions from the system.
     *
     * @return list of all transactions with their details including ID, source account,
     *         destination account, amount, and timestamp
     */
    @Transactional(readOnly = true)
    public List<TransactionResponse> getAllTransactions() {
        logger.debug("Retrieving all transactions");
        List<Transaction> transactions = transactionRepository.findAll();
        logger.debug("Retrieved {} transactions", transactions.size());
        
        metricsService.recordTransactionQuery();
        
        return transactions.stream()
                .map(transaction -> new TransactionResponse(
                        transaction.getId(),
                        transaction.getSourceAccountId(),
                        transaction.getDestinationAccountId(),
                        transaction.getAmount(),
                        transaction.getTimestamp()
                ))
                .collect(Collectors.toList());
    }
}

